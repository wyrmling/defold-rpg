local range = require("utils.range")
local dbg = require("utils.dbg")
local inspect = require("utils.inspect")

local moves = {
    move_left = { x = -1, y = 0 },
    move_right = { x = 1, y = 0 },
    move_up = { x = 0, y = 1 },
    move_down = { x = 0, y = -1 },
}

go.property('health', 10)

function init(self)
    --self.health = 123

    msg.post(".", "acquire_input_focus")
end

function final(self)
    -- Add finalization code here
    -- Remove this function if not needed
end

function update(self, dt)
    local labelC = {go.get('#label', 'color'), '<-color'}
    --print(labelC[1], labelC[2])

    msg.post("#camera", "acquire_camera_focus")
    --msg.post("/enemy#camera", "acquire_camera_focus")
    --msg.post("/gui#camera", "acquire_camera_focus")

    label.set_text("#label", self.health)
    local grey = vmath.vector4(1, 0, 0, 1.0)
    go.set("player#label", "color", grey)
    --go.set("#label", "outline.w", 0)
    --go.set("#label", "scale.x", scale_x * 2)
    --print(tilemap.get_tile("/level#tilemap", "walls", 2, 4))
    local doorpos = vmath.vector3(30, 30, 0)
    --print(
        --tilemap.get_tile("/level#tilemap", "walls", 3, 4),
    --    tilemap.get_tile("/level#tilemap", "walls", doorpos)
    --)
    --msg.ge
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = math.random(1,16)})
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("walls"), position = doorpos, tile = math.random(1,16)})
end

function on_message(self, message_id, message, sender)
    if message_id == hash("damage") then
        self.health = self.health - message.damage
        if self.health <= 0 then
            go.delete()
        end
    end
end

function on_input(self, action_id, action)

    local pass_map = build_pass_map(self)

    --dbg.log(pass_map)
--    print(inspect(pass_map))
	local direction = get_direction(action_id)
--    print(direction)

    if action.pressed and passable(direction) then
        local pos = go.get_position()
        pos.x = pos.x + T_SIZE * moves[direction].x
        pos.y = pos.y + T_SIZE * moves[direction].y
        go.set_position(pos)
    end

    if action.pressed then
        msg.post('level#map', 'take_turn')
    end
    --local t = tilemap.get_tile('level#tilemap', 'walls', self.player_x, self.player_y)
    --print(t)
    --local pos = go.get_position()
    --local doorpos = vmath.vector3(pos.x, pos.y, 0)
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = math.random(1,16)})
    -- Upper part of door can be adressed with same position and "dy" set to 1.
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = 46, dy = 1 })
end

function on_reload(self)
    -- Add reload-handling code here
    -- Remove this function if not needed
end

function passable(direction)
    local pos = go.get_tile_pos()

	if tilemap.get_tile('level#tilemap', 'walls', pos.x + moves[direction].x, pos.y + moves[direction].y) == 0 then
        return true
    else
        return false
    end
end

function get_direction(action_id)
    if action_id == hash('move_left') then
        return 'move_left'
    elseif action_id == hash('move_right') then
        return 'move_right'
    elseif action_id == hash('move_up') then
        return 'move_up'
    elseif action_id == hash('move_down') then
        return 'move_down'
    else
        return false
    end
end

function build_pass_map()
	local pass_map2 = {{x=1,y=1}, {x=2,y=2}}
	return pass_map2
end