local range = require("utils.range")
local dbg = require("utils.dbg")

go.property("health", 10)
go.property("pass_map", {})

function init(self)
    --self.health = 123

    msg.post(".", "acquire_input_focus")
end

function final(self)
    -- Add finalization code here
    -- Remove this function if not needed
end

function update(self, dt)
    local labelC = {go.get('#label', 'color'), '<-color'}
    --print(labelC[1], labelC[2])

    msg.post("#camera", "acquire_camera_focus")
    --msg.post("/enemy#camera", "acquire_camera_focus")
    --msg.post("/gui#camera", "acquire_camera_focus")

    label.set_text("#label", self.health)
    local grey = vmath.vector4(1, 0, 0, 1.0)
    go.set("player#label", "color", grey)
    --go.set("#label", "outline.w", 0)
    --go.set("#label", "scale.x", scale_x * 2)
    --print(tilemap.get_tile("/level#tilemap", "walls", 2, 4))
    local doorpos = vmath.vector3(30, 30, 0)
    --print(
        --tilemap.get_tile("/level#tilemap", "walls", 3, 4),
    --    tilemap.get_tile("/level#tilemap", "walls", doorpos)
    --)
    --msg.ge
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = math.random(1,16)})
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("walls"), position = doorpos, tile = math.random(1,16)})
end

function on_message(self, message_id, message, sender)
    if message_id == hash("damage") then
        self.health = self.health - message.damage
        if self.health <= 0 then
            go.delete()
        end
    end
end

function on_input(self, action_id, action)


    print(hash("move_left"))
    
    build_pass_map(self)
    
    dbg.log(self.pass_map)

    if action.pressed and passable(action_id) then

        if action_id == hash('move_left') then
            local pos = go.get_position()
            pos.x = pos.x - T_SIZE
            go.set_position(pos)
            --print(go.get_position('/player'), go.get_position())
            --msg.post("/enemy#camera", "acquire_camera_focus")
        elseif action_id == hash('move_right') then
            local pos = go.get_position()
            pos.x = pos.x + T_SIZE
            go.set_position(pos)
        elseif action_id == hash('move_up') then
            local pos = go.get_position()
            pos.y = pos.y + T_SIZE
            go.set_position(pos)
        elseif action_id == hash('move_down') then
            local pos = go.get_position()
            pos.y = pos.y - T_SIZE
            go.set_position(pos)
        end

    end

    if action.pressed then
        msg.post('level#map', 'take_turn')
    end
    --local t = tilemap.get_tile('level#tilemap', 'walls', self.player_x, self.player_y)
    --print(t)
    --local pos = go.get_position()
    --local doorpos = vmath.vector3(pos.x, pos.y, 0)
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = math.random(1,16)})
    -- Upper part of door can be adressed with same position and "dy" set to 1.
    --msg.post("/level#tilemap", "set_tile", { layer_id = hash("floor"), position = doorpos, tile = 46, dy = 1 })
end

function passable(direction)
    local pos = go.get_tile_pos()

    if direction == hash('move_left') and tilemap.get_tile('level#tilemap', 'walls', pos.x-1, pos.y) == 0 then
        return true
    elseif direction == hash('move_right') and tilemap.get_tile('level#tilemap', 'walls', pos.x+1, pos.y) == 0 then
        return true
    elseif direction == hash('move_up') and tilemap.get_tile('level#tilemap', 'walls', pos.x, pos.y+1) == 0 then
        return true
    elseif direction == hash('move_down') and tilemap.get_tile('level#tilemap', 'walls', pos.x, pos.y-1) == 0 then
        return true
    else
        return false
    end
end

function on_reload(self)
    -- Add reload-handling code here
    -- Remove this function if not needed
end

function build_pass_map(self)
	local pass_map2 = {{x=1,y=1}, {x=2,y=2}}
	self.pass_map = pass_map2
end