local defos = require("utils.defos")
local inspect = require("utils.inspect")

local obj_pos = {}
local battle_order = {}
--go.property('battle_order_active', hash('/player#player'))
go.property('battle_order_active', msg.url('/player#player'))

--local id = go.get_id()
--go.set(id,'battle_order_active',0)

T_SIZE = 16

go.property("turn", 0)

function init(self)
	defos.disable_window_resize()

	--local p = go.get_position()
	--p.y = vmath.lerp(math.random(), min_y, max_y)
	--local component = "#star_factory"
	--table.insert(battle_order, {id = msg.url('/player#player'), name = 'player', order = true})
	table.insert(battle_order, {id = msg.url('/player#player'), name = 'player', order = true})

	--init battle order	
	local enemy_id = factory.create('/enemies#factory', vmath.vector3(40,80,0))
	table.insert(battle_order, {id = enemy_id, name = 'enemy', order = false})
	--self.battle_order[enemy_id] = {name = 'enemy', order = false}
	
		
	--msg.post('#calm_theme', 'play_sound', {gain = 0.1})
	
	
end

function final(self)

end

function update(self, dt)
	-- тут должен быть цикл из объектов и их ходов
	-- вместо этого пока что хардкод

	--particlefx.play('/particle_test#particlefx')
	--particlefx.play('/particle_test2#particlefx1')
end

function on_message(self, message_id, message, sender)
	
	if message_id == hash('get_battle_order') then
		return self.battle_order
	end
	
	if message_id == hash("obj_pos") then
		obj_pos[sender] = message.x, message.y
	end
	--print(inspect(obj_pos))
	--print('---')
	--print(sender, message.x, message.y)
	
	if message_id == hash("take_turn") then
		--print(inspect(battle_order))
		
		--pprint(sender)
		
		--scroll_msg('turn taken', sender)
		
		--print(self.battle_order_active)
		
		for key, char in ipairs(battle_order) do
			--pprint(char.id, self.battle_order_active)
			--print(char.id, self.battle_order_active)
        	if char.id == self.battle_order_active then
        		--print(#battle_order, key)
        		--battle_order[key].order = false
        		if #battle_order == key then
        		--	battle_order[1].order = true
        			self.battle_order_active = battle_order[1].id
        			break
        		else
        		--	battle_order[key+1].order = true
        			self.battle_order_active = battle_order[key+1].id
        			break
        		end
        	end
        	--print(hash('/player#player'))
        	--print(self.battle_order_active)
        	--self.battle_order_active = battle_order[2].id
        	--print(go.get('/player#player','health'))
        	
        end
        
        --pprint(battle_order)
        --print(self.battle_order_active)
		
        --pprint(hash('/player#player'))
        --print(go.get(self.battle_order_active,'health'))
        --print(go.get(msg.url('player#player'),'health'))
        
        --print(go.get('/player#player','health'))
        --pprint(go.get(hash('/player#player'),'health'))
        
		--scroll_msg('turn sent', self.battle_order_active)
        
        msg.post(self.battle_order_active, 'take_turn')
        --pprint(self.battle_order_active)
    end
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

function next_turn()
	self.turn = self.turn + 1
    label.set_text("#label_turn", self.turn)
    go.set("#label_turn", "color", vmath.vector4(0, 0.2, 0.5, 1))
end

function init_battle_order()
	
end

function get_battle_order()
	return self.battle_order	
end

function scroll_msg(text_message, url)
	--print(url, go.get_id(), msg.url())
	--print(text_message .. ' by ' .. url)
	--pprint(url)
	--print(go.get_id(url))
	--msg.url()
	--go.ge
	--local msg_label = factory.create('#msg_label_factory', nil, nil, {temp = true})
	--print(msg_label)
	--msg.post(msg_label, 'scrolling_line', {text = text_message})
end

function send_obj_pos()
	local pos = go.get_position()
	msg.post('/level#map', 'obj_pos', {x = pos.x, y = pos.y})
end

function next_turn()
	send_obj_pos()
	--print('turn sent by ' .. msg.url())
	--label.set_text("#msg_label_factory", 'turn sent')
	scroll_msg('turn sent')
	msg.post('level#map', 'take_turn')
end

function scroll_msg(text_message)
	--print(msg.url('#msg_label_factory'), msg.url())
	--print(go.get_id('#msg_label_factory'))
	local msg_label = factory.create('#msg_label_factory', nil, nil, {temp = true})
	msg.post(msg_label, 'scrolling_line', {text = text_message})
end
